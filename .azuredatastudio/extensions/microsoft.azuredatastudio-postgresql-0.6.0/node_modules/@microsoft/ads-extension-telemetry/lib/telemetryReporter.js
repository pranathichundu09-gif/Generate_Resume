"use strict";
/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const extension_telemetry_1 = require("@vscode/extension-telemetry");
const timedAction_1 = require("./timedAction");
/**
 * List of domain names that we use to determine if a user is internal to Microsoft.
 */
const msftInternalDomains = [
    "redmond.corp.microsoft.com",
    "northamerica.corp.microsoft.com",
    "fareast.corp.microsoft.com",
    "ntdev.corp.microsoft.com",
    "wingroup.corp.microsoft.com",
    "southpacific.corp.microsoft.com",
    "wingroup.windeploy.ntdev.microsoft.com",
    "ddnet.microsoft.com",
    "europe.corp.microsoft.com"
];
/**
 * Attempts to determine whether this machine is an MSFT internal user. This is not 100% accurate and isn't
 * meant to be, but is good enough for our cases.
 * @returns true if internal, false otherwise
 */
function isMsftInternal() {
    // Original logic from https://github.com/Microsoft/azuredatastudio/blob/9a14fef8075965f62c2d4efdfa1a30bf6ddddcf9/src/vs/platform/telemetry/common/telemetryUtils.ts#L260
    // This is a best-effort guess using the DNS domain for the user
    const userDnsDomain = process.env['USERDNSDOMAIN'];
    if (!userDnsDomain) {
        return false;
    }
    const domain = userDnsDomain.toLowerCase();
    return msftInternalDomains.some(msftDomain => domain === msftDomain);
}
const commonMeasurements = {
    // Use a number since that's what ADS core uses.
    // NOTE: We do NOT set the UTC flag like core
    // (https://github.com/Microsoft/azuredatastudio/blob/9a14fef8075965f62c2d4efdfa1a30bf6ddddcf9/src/vs/platform/telemetry/common/1dsAppender.ts#L53)
    // since we don't have direct access to the internal appender instance and currently the package
    // only sets that flag is "telemetry.internalTesting" is true
    // https://github.com/microsoft/vscode-extension-telemetry/blob/04e50fbc94a922f5e2ee6eb2cf2236491f1f99d9/src/common/1dsClientFactory.ts#L52
    'common.msftInternal': isMsftInternal() ? 1 : 0
};
const commonProperties = {};
try {
    const azdata = require('azdata');
    commonProperties['common.adsversion'] = azdata === null || azdata === void 0 ? void 0 : azdata.version;
}
catch (err) {
    // no-op when we're not in a context that has azdata available
}
class TelemetryEventImpl {
    constructor(reporter, eventName, properties, measurements) {
        this.reporter = reporter;
        this.eventName = eventName;
        this.properties = properties;
        this.measurements = measurements;
        this.properties = properties || {};
        Object.assign(this.properties, commonProperties);
        this.measurements = measurements || {};
        Object.assign(this.measurements, commonMeasurements);
    }
    send() {
        var _a;
        try {
            (_a = this.reporter) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(this.eventName, this.properties, this.measurements);
        }
        catch (e) {
            // We don't want exceptions sending telemetry to break extensions so just log and ignore
            const msg = e instanceof Error ? e.message : e;
            console.error(`Error sending ${this.eventName} event ${msg}`);
        }
    }
    withAdditionalProperties(additionalProperties) {
        Object.assign(this.properties, additionalProperties);
        return this;
    }
    withAdditionalMeasurements(additionalMeasurements) {
        Object.assign(this.measurements, additionalMeasurements);
        return this;
    }
    withConnectionInfo(connectionInfo) {
        Object.assign(this.properties, {
            authenticationType: connectionInfo.authenticationType,
            providerName: connectionInfo.providerName,
            serverType: connectionInfo.serverType,
            engineType: connectionInfo.engineType
        });
        return this;
    }
}
class TelemetryReporter {
    /**
     *
     * @param extensionId The ID of the extension sending the event
     * @param extensionVersion The version of the extension sending the event
     * @param key The AI Key to use
     */
    constructor(extensionId, extensionVersion, key) {
        var _a, _b;
        this._telemetryReporter = undefined;
        // Try to initialize the reporter, but don't throw if it fails so we don't break the extension
        try {
            this._telemetryReporter = new extension_telemetry_1.default(extensionId, extensionVersion, key);
        }
        catch (e) {
            console.error(`Error initializing TelemetryReporter for '${extensionId}'. ${(_b = (_a = e) === null || _a === void 0 ? void 0 : _a.message) !== null && _b !== void 0 ? _b : e}`);
        }
    }
    /**
     * Creates a View event that can be sent later. This is used to log that a particular page or item was seen.
     * @param view The name of the page or item that was viewed
     */
    createViewEvent(view) {
        return new TelemetryEventImpl(this._telemetryReporter, 'view', {
            view: view
        });
    }
    /**
     * Sends a View event. This is used to log that a particular page or item was seen.
     * @param view The name of the page or item that was viewed
     */
    sendViewEvent(view) {
        this.createViewEvent(view).send();
    }
    /**
     * Creates an Action event that can be sent later. This is used to log when an action was taken, such as clicking a button.
     * @param view The name of the page or item where this action occurred
     * @param action The name of the action taken
     * @param target The name of the item being acted on
     * @param source The source of the action
     * @param durationInMs The duration the action took to execute
     */
    createActionEvent(view, action, target = '', source = '', durationInMs) {
        const measures = durationInMs ? { durationInMs: durationInMs } : {};
        return new TelemetryEventImpl(this._telemetryReporter, 'action', {
            view: view,
            action: action,
            target: target,
            source: source
        }, measures);
    }
    /**
     * Sends a Action event. This is used to log when an action was taken, such as clicking a button.
     * @param view The name of the page or item where this action occurred
     * @param action The name of the action taken
     * @param target The name of the item being acted on
     * @param source The source of the action
     * @param durationInMs The duration the action took to execute
     */
    sendActionEvent(view, action, target = '', source = '', durationInMs) {
        this.createActionEvent(view, action, target, source, durationInMs).send();
    }
    /**
     * Creates a TimedAction - which will create and send an action event with a duration when send() is called. The timer
     * starts on construction and ends when send() is called.
     * @param view The view this action originates from
     * @param action The name of the action
     * @param target The name of the item being acted on
     * @param source The source of the action
     * @returns The TimedAction object
     */
    createTimedAction(view, action, target, source) {
        return new timedAction_1.TimedAction(this, view, action, target, source);
    }
    /**
     * Creates a Metrics event that can be sent later. This is used to log measurements taken.
     * @param measurements The metrics to send
     * @param groupName The name of the group these measurements belong to
     */
    createMetricsEvent(measurements, groupName = '') {
        return new TelemetryEventImpl(this._telemetryReporter, 'metrics', { groupName: groupName }, measurements);
    }
    /**
     * Sends a Metrics event. This is used to log measurements taken.
     * @param measurements The measurements to send
     * @param groupName The name of the group these measurements belong to
     */
    sendMetricsEvent(measurements, groupName = '') {
        this.createMetricsEvent(measurements, groupName).send();
    }
    /**
     * Creates a new Error event that can be sent later. This is used to log errors that occur.
     * @param view The name of the page or item where the error occurred
     * @param name The friendly name of the error
     * @param errorCode The error code returned
     * @param errorType The specific type of error
     * @deprecated Use createErrorEvent2
     */
    createErrorEvent(view, name, errorCode = '', errorType = '') {
        return new TelemetryEventImpl(this._telemetryReporter, 'error', {
            view: view,
            name: name,
            errorCode: errorCode,
            errorType: errorType
        });
    }
    /**
     * Sends a Error event. This is used to log errors that occur.
     * @param view The name of the page or item where the error occurred
     * @param name The friendly name of the error
     * @param errorCode The error code returned
     * @param errorType The specific type of error
     * @deprecated Use sendErrorEvent2
     */
    sendErrorEvent(view, name, errorCode = '', errorType = '') {
        this.createErrorEvent(view, name, errorCode, errorType).send();
    }
    /**
     * Creates a new Error event that can be sent later. This is used to log errors that occur.
     * @param view The name of the page or item where the error occurred
     * @param name The friendly name of the error
     * @param error The error. If an Error object the message and stack will be extracted and added to the event, otherwise the message will be set to error.toString()
     * @param errorCode The error code returned, default is empty
     * @param errorType The specific type of error, default is empty
     */
    createErrorEvent2(view, name, error = undefined, errorCode = '', errorType = '') {
        const props = {
            view: view,
            name: name,
            errorCode: errorCode,
            errorType: errorType
        };
        if (error instanceof Error) {
            props.message = error.message;
            props.stack = error.stack || '';
        }
        else {
            props.message = error === null || error === void 0 ? void 0 : error.toString();
            props.stack = '';
        }
        return new TelemetryEventImpl(this._telemetryReporter, 'error', props);
    }
    /**
     * Sends a Error event. This is used to log errors that occur.
     * @param view The name of the page or item where the error occurred
     * @param name The friendly name of the error
     * @param error The error object. If an Error object the message and stack will be extracted and added to the event, otherwise the message will be set to error.toString()
     * @param errorCode The error code returned
     * @param errorType The specific type of error
     */
    sendErrorEvent2(view, name, error = undefined, errorCode = '', errorType = '') {
        this.createErrorEvent2(view, name, error, errorCode, errorType).send();
    }
    /**
     * Creates a custom telemetry event with the specified name that can be sent later. Generally the other send functions should be
     * preferred over this - only use this if you absolutely need a custom event that can't be covered by the other methods.
     * @param eventName The name of the event. Will be prefixed with <extension-name>/
     * @param properties The list of properties to send along with the event
     * @param measurements The list of measurements to send along with the event
     */
    createTelemetryEvent(eventName, properties, measurements) {
        return new TelemetryEventImpl(this._telemetryReporter, eventName, properties, measurements);
    }
    /**
     * Sends a custom telemetry event with the specified name. Generally the other send functions should be
     * preferred over this - only use this if you absolutely need a custom event that can't be covered by the other
     * @param eventName The name of the event. Will be prefixed with <extension-name>/
     * @param properties The list of properties to send along with the event
     * @param measurements The list of measurements to send along with the event
     */
    sendTelemetryEvent(eventName, properties, measurements) {
        this.createTelemetryEvent(eventName, properties, measurements).send();
    }
    /**
     * Disposes of the telemetry reporter. This flushes the remaining events and disposes of the telemetry client.
     */
    dispose() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            yield ((_a = this._telemetryReporter) === null || _a === void 0 ? void 0 : _a.dispose());
        });
    }
}
exports.default = TelemetryReporter;
//# sourceMappingURL=telemetryReporter.js.map